# 类：

## 抽象定义：(private-卧室，public-客厅，friend-朋友，main-客人)

构建一个新的函数类型，它所包含的相当于是他的几个==特征函数==，这几个特征函数共同衡量区分这个物体，类是对对象的抽象，对象时类的具体实例；类不占内存，对象占内存。 #remember-for-later
 
## Struct和Class的异同：

1. struct和class的声明具有相同效果
2. C++兼容所有c程序
3. struct默认的是 public，类中默认的是 private 状态

## 文件组成：

- 利用类实现接口与实现相分离，即程序内部的函数更改，但是调用接口不变
- 类声明和函数定义放在两个文件中，包含3部分：
    
    1. 类声明头文件(.h)
    2. 类实现文件(.cpp)，包括成员函数的定义
    3. 主函数(.cpp)

成员函数(member function)  
构造函数进行初始化，函数名与类名一致，无函数类型和返回值，其==不可以被调用==  
默认构造函数：==无实参==的构造函数。定义对象的语句是 Box box1，不是Box box1( )  
析构函数：先构造的后析构，后构造的先析构（栈：先进后出）  
本质上--函数将 ==this== 指针指向操作对象 #important  
静态数据成员是为了某个数据在整个程序中的变化是统一的，牵一发而动全身，可被所有函数调用  
静态成员函数主要用来访问静态数据成员，不访问非静态成员

- 不属于class但是可以调用private成员（行使与public一样的权力）
- 友元可以帮助实现类与类之间的私有成员的调用，实现一个函数调用多个类中的私有数据
- 友元包括友元函数和友元类-==单向==的关系

==通过private可以实现信息隐蔽==

友元（friend）
 
# C++对C的扩充：

## new与delete，进行动态空间的创建和释放

- ## new与delete，进行动态空间的创建和释放
    

int *p=new int;  
delete p;  
int *p=new int(10);  
delete p;  
int *p=new int[10];  
delete [] p;  
p=NULL;
 - ## 运算符重载：
    

函数类型 operator 运算符名称(参数表)

- ## 函数重载：
    

overloading 允许某个东西在不同场合具有不同功能--一个函数名多用--针对函数多用提供了==函数模板==

- ## 函数模板：
    

template <typename/class T1, typename/class T2>

- ## 内联函数：
    

inline--代码行少但是调用频繁的函数，减少运行时间

## Const成员
    - 常数据成员：int const a；const int a
    - 常对象：Time const a；const Time a
    - 常成员函数：void get_time( ) const；
        - 类型名 函数名（参数表） const {}
        - 不能修改数据成员，不能调用非常成员函数
        - 常对象只能调用常成员函数
    - 指向对象的常指针：Time * const ptr
    - 指向常对象的指针变量：const char *ptr ； char const *ptr
    - 对象的常引用：const int &a；int const &a
 
## 运算符重载：

## 函数重载：

## 函数模板：

## 内联函数：

## Const成员

不能被赋值，只能被初始化 #important

# 编程范式：

计算机编程的基本风格或典范模式

- 过程式
- 面向对象
- 函数式
- 泛型编程

# 面向对象(Object Oriented Programming,OOP)

## 四大特性：

- ## 四大特性：
    
    - 抽象、封装、继承、多态性
    - 封装和继承使代码重用
    - 多态使接口重用
- ## 组成：
    
    - 低级语言-继承于C语言
    - 现代高级语言特性-允许自定义
    - 标准库-通过自定义提供有用的数据结构和算法
- ## 逻辑关系：
    
    - 对象=算法+数据结构
    - 程序=对象S+消息（对对象的调用指令）

## 组成：

## 逻辑关系：

# 复合类型：引用和指针的区别

1. 引用必须初始化：从定义开始把引用和初始值绑定在一起，二者将一直被绑定在一起，它只是一个别名： int val; ==int== ==&a=====val;== 则a为val的一个别名
2. 引用的初始值必须是对象，且类型必须与初始值一致
3. 指针本身就是一个对象，允许对其赋值拷贝，可以更改所指的对象，无需赋初值（空指针）

# Win 32 GUI

- 消息响应(message based)
- 事件驱动(event driven)

## Windows程序流程

1. 注册windows类
2. 建立windows窗口
3. 消息循环
4. 消息响应

## 多态性与虚函数

![[Exported image 20240403195411-0.png|multi state|600]]
- 目的：使接口重用
- 普遍用法：拿一个父类的指针去调用子类中被重写的方法
- 为了实现不同输入产生不同输出，而用的又可以公用一个接口（类似于硬件里面一个外设接口可以连接鼠标、键盘等不同硬件）
- 允许将子类类型的指针赋值给父类类型的指针，调用同名函数却会因==上下文==的不同而有不同的实现。 虚表
- 虚函数的定义要遵循以下重要规则：
    
    1. 如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。
    2. 只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。
    3. 静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。
    4. 内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。
    5. 构造函数不能是虚函数，因为构造的时候，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。
    6. 析构函数可以是虚函数,而且通常声名为虚函数。
 
- 纯虚函数

virtual 函数类型 函数名（参数表）=0；

- 抽象类
    
    1. 定义了纯虚函数的类
    2. 目的是用来作为基类去建立派生类
    3. 为一个类族提供一个公共接口