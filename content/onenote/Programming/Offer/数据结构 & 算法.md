**基础类型：**数组、字符串--连续内存空间  
数组相当于是哈希表(**键值****-****值**) O(1)  
32位系统上，指针空间为 4 字节
 
**字符串：**  
C++中的字符串都是以“\0” 结尾的“ \”指的是转义字符
 
合并两个数组时，可以考虑从后往前复制  
问面试官是否可以修改输入的数据  
递归的本质就是栈，因此能用栈实现的都可以用递归实现
 
**链表：**  
首先需要考虑第一个节点  
然后利用 first->next进行循环查找
 
**树：**  
注意对多种情况的分析  
同if & else 进行条件区分
 
vector.empty()：当其为空时，返回值为0  
若面试官没有特殊要求，优先采用递归的方法进行编程
 
**位运算**  
异或结构  
x & (x - 1) 用于消去x最后一位的1

实现方式：递归 & 循环  
排序、查找：二分查找、归并排序、快速排序  
二维数组搜索路径-用递归方法  
最优解问题--动态规划  
分解子问题的特殊选择--贪心算法  
递归的不足--调用栈溢出
 
**动态规划（****DP****）：**  
[https://www.zhihu.com/search?type=content&q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92](https://www.zhihu.com/search?type=content&q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

- 比较：
    
    1. 贪心算法--鼠目寸光--每次只取最大--对最优解不适用
    2. 暴力枚举--将所有情况都多列出来--浪费时间空间
    3. 回溯法：适合多步骤的问题（DFS、BFS），是枚举的升级--递归实现
- 定义：将一个问题拆分成几个子问题，分别求解子问题，判断出大问题
- 性质：
    
    1. 无后效性：未来与过去无关，不在乎如何得出过去的结果
    2. 最优子结构：由小问题的最优解组合而成
- 讨论：
    
    1. 核心思想：尽量缩小可能解空间，而暴力枚举的解空间最大
    2. 操作流程：大事化小，小事化了
    3. 算法步骤：设计状态（我是什么）->设计转移（从哪儿来/到哪儿去）
 
查找：顺序查找、二分查找、哈希表查找、二叉排序树  
在排序数组中查找数或同级出现次数--二叉查找树  
排序：快排，归并排序、堆排

![Name dubble sort Selection sort Insertion soft Best n Merge soft n. log n, In-place merge sort Average n log n n logn n log n Worst 2 n logn n (log n log n Memory 1 1 1 worst case is n. 1 Stable No Yes Yes Yes typical in- Quicksolt Heapsort n log n n log n. n on average, worst case is place sort is not stable, 1 ](Exported%20image%2020240403195452-0.png)

1. Merge sort：2路归并排序，n个长度为1的子序列-n/2个长度为2或1的子序列->1个
2. Quick sork：选中心值，使左边都小于它，右边都大于它，然后递归
3. Heap sort：完全二叉树--需要构造，因此适合个数多的情况

**数字形式**  
A[.[B]][e|EC]、.B[e|EC]

1. A、C为整数，可以有符号
2. B为无符号整数